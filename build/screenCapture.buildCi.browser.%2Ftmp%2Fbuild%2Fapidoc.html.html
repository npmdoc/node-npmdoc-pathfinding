<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/qiao/PathFinding.js">pathfinding (v0.4.18)</a>
</h1>
<h4>Comprehensive pathfinding library for grid based games</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding">module pathfinding</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.AStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>AStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BestFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BestFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiAStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiAStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBestFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiBestFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBreadthFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiBreadthFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiDijkstraFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiDijkstraFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BreadthFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BreadthFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.DijkstraFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>DijkstraFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid">
            function <span class="apidocSignatureSpan">pathfinding.</span>Grid
            <span class="apidocSignatureSpan">(width_or_matrix, height, matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap">
            function <span class="apidocSignatureSpan">pathfinding.</span>Heap
            <span class="apidocSignatureSpan">(cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.IDAStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>IDAStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFAlwaysMoveDiagonally
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfAtMostOneObstacle
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfNoObstacles
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFNeverMoveDiagonally
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JumpPointFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JumpPointFinderBase">
            function <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinderBase
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Node">
            function <span class="apidocSignatureSpan">pathfinding.</span>Node
            <span class="apidocSignatureSpan">(x, y, walkable)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>AStarFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>BestFirstFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>BiAStarFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>BiBestFirstFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>BiBreadthFirstFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>BiDijkstraFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>BreadthFirstFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>DiagonalMovement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>DijkstraFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>Grid.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>Heap.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>Heuristic</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>IDAStarFinder.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>JPFAlwaysMoveDiagonally.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfAtMostOneObstacle.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfNoObstacles.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>JPFNeverMoveDiagonally.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinderBase.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>PathFinding</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>Util</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>parse_map</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.</span>parse_scen</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.AStarFinder">module pathfinding.AStarFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.AStarFinder.AStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>AStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.AStarFinder.prototype">module pathfinding.AStarFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.AStarFinder.prototype.findPath">
            function <span class="apidocSignatureSpan">pathfinding.AStarFinder.prototype.</span>findPath
            <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BestFirstFinder">module pathfinding.BestFirstFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BestFirstFinder.BestFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BestFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BestFirstFinder.prototype">module pathfinding.BestFirstFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BestFirstFinder.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.BestFirstFinder.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BestFirstFinder.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.BestFirstFinder.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.BestFirstFinder.prototype.</span>diagonalMovement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.BestFirstFinder.prototype.</span>weight</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiAStarFinder">module pathfinding.BiAStarFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiAStarFinder.BiAStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiAStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiAStarFinder.prototype">module pathfinding.BiAStarFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiAStarFinder.prototype.findPath">
            function <span class="apidocSignatureSpan">pathfinding.BiAStarFinder.prototype.</span>findPath
            <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiBestFirstFinder">module pathfinding.BiBestFirstFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBestFirstFinder.BiBestFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiBestFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiBestFirstFinder.prototype">module pathfinding.BiBestFirstFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBestFirstFinder.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.BiBestFirstFinder.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBestFirstFinder.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.BiBestFirstFinder.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.BiBestFirstFinder.prototype.</span>diagonalMovement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.BiBestFirstFinder.prototype.</span>weight</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiBreadthFirstFinder">module pathfinding.BiBreadthFirstFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBreadthFirstFinder.BiBreadthFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiBreadthFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiBreadthFirstFinder.prototype">module pathfinding.BiBreadthFirstFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiBreadthFirstFinder.prototype.findPath">
            function <span class="apidocSignatureSpan">pathfinding.BiBreadthFirstFinder.prototype.</span>findPath
            <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiDijkstraFinder">module pathfinding.BiDijkstraFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiDijkstraFinder.BiDijkstraFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BiDijkstraFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BiDijkstraFinder.prototype">module pathfinding.BiDijkstraFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiDijkstraFinder.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.BiDijkstraFinder.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BiDijkstraFinder.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.BiDijkstraFinder.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.BiDijkstraFinder.prototype.</span>diagonalMovement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.BiDijkstraFinder.prototype.</span>weight</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BreadthFirstFinder">module pathfinding.BreadthFirstFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BreadthFirstFinder.BreadthFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>BreadthFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.BreadthFirstFinder.prototype">module pathfinding.BreadthFirstFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.BreadthFirstFinder.prototype.findPath">
            function <span class="apidocSignatureSpan">pathfinding.BreadthFirstFinder.prototype.</span>findPath
            <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.DijkstraFinder">module pathfinding.DijkstraFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.DijkstraFinder.DijkstraFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>DijkstraFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.DijkstraFinder.prototype">module pathfinding.DijkstraFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.DijkstraFinder.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.DijkstraFinder.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.DijkstraFinder.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.DijkstraFinder.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.DijkstraFinder.prototype.</span>diagonalMovement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">pathfinding.DijkstraFinder.prototype.</span>weight</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.Grid">module pathfinding.Grid</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.Grid">
            function <span class="apidocSignatureSpan">pathfinding.</span>Grid
            <span class="apidocSignatureSpan">(width_or_matrix, height, matrix)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.Grid.prototype">module pathfinding.Grid.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype._buildNodes">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>_buildNodes
            <span class="apidocSignatureSpan">(width, height, matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype.clone">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype.getNeighbors">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>getNeighbors
            <span class="apidocSignatureSpan">(node, diagonalMovement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype.getNodeAt">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>getNodeAt
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype.isInside">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>isInside
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype.isWalkableAt">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>isWalkableAt
            <span class="apidocSignatureSpan">(x, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Grid.prototype.setWalkableAt">
            function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>setWalkableAt
            <span class="apidocSignatureSpan">(x, y, walkable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.Heap">module pathfinding.Heap</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.Heap">
            function <span class="apidocSignatureSpan">pathfinding.</span>Heap
            <span class="apidocSignatureSpan">(cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.heapify">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>heapify
            <span class="apidocSignatureSpan">(array, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.nlargest">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>nlargest
            <span class="apidocSignatureSpan">(array, n, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.nsmallest">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>nsmallest
            <span class="apidocSignatureSpan">(array, n, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.pop">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>pop
            <span class="apidocSignatureSpan">(array, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.push">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>push
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.pushpop">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>pushpop
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.replace">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>replace
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.updateItem">
            function <span class="apidocSignatureSpan">pathfinding.Heap.</span>updateItem
            <span class="apidocSignatureSpan">(array, item, cmp)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.Heap.prototype">module pathfinding.Heap.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.clear">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.clone">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.contains">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>contains
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.copy">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>copy
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.empty">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>empty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.front">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>front
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.has">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>has
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.heapify">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>heapify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.insert">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>insert
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.peek">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>peek
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.pop">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>pop
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.push">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>push
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.pushpop">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>pushpop
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.replace">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>replace
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.size">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>size
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.toArray">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>toArray
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.top">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>top
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heap.prototype.updateItem">
            function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>updateItem
            <span class="apidocSignatureSpan">(x)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.Heuristic">module pathfinding.Heuristic</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heuristic.chebyshev">
            function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>chebyshev
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heuristic.euclidean">
            function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>euclidean
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heuristic.manhattan">
            function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>manhattan
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Heuristic.octile">
            function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>octile
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.IDAStarFinder">module pathfinding.IDAStarFinder</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.IDAStarFinder.IDAStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.</span>IDAStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.IDAStarFinder.prototype">module pathfinding.IDAStarFinder.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.IDAStarFinder.prototype.findPath">
            function <span class="apidocSignatureSpan">pathfinding.IDAStarFinder.prototype.</span>findPath
            <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFAlwaysMoveDiagonally">module pathfinding.JPFAlwaysMoveDiagonally</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.JPFAlwaysMoveDiagonally">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFAlwaysMoveDiagonally
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFAlwaysMoveDiagonally.prototype">module pathfinding.JPFAlwaysMoveDiagonally.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>trackJumpRecursion</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype._findNeighbors">
            function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>_findNeighbors
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype._jump">
            function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>_jump
            <span class="apidocSignatureSpan">(x, y, px, py)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle">module pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.JPFMoveDiagonallyIfAtMostOneObstacle">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfAtMostOneObstacle
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype">module pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>trackJumpRecursion</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>_findNeighbors
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>_jump
            <span class="apidocSignatureSpan">(x, y, px, py)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfNoObstacles">module pathfinding.JPFMoveDiagonallyIfNoObstacles</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.JPFMoveDiagonallyIfNoObstacles">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfNoObstacles
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype">module pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>trackJumpRecursion</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>_findNeighbors
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype._jump">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>_jump
            <span class="apidocSignatureSpan">(x, y, px, py)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFNeverMoveDiagonally">module pathfinding.JPFNeverMoveDiagonally</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.JPFNeverMoveDiagonally">
            function <span class="apidocSignatureSpan">pathfinding.</span>JPFNeverMoveDiagonally
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JPFNeverMoveDiagonally.prototype">module pathfinding.JPFNeverMoveDiagonally.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>trackJumpRecursion</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype._findNeighbors">
            function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>_findNeighbors
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype._jump">
            function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>_jump
            <span class="apidocSignatureSpan">(x, y, px, py)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype.constructor">
            function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>constructor
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype.heuristic">
            function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>heuristic
            <span class="apidocSignatureSpan">(dx, dy)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JumpPointFinderBase">module pathfinding.JumpPointFinderBase</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JumpPointFinderBase.JumpPointFinderBase">
            function <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinderBase
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.JumpPointFinderBase.prototype">module pathfinding.JumpPointFinderBase.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JumpPointFinderBase.prototype._identifySuccessors">
            function <span class="apidocSignatureSpan">pathfinding.JumpPointFinderBase.prototype.</span>_identifySuccessors
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.JumpPointFinderBase.prototype.findPath">
            function <span class="apidocSignatureSpan">pathfinding.JumpPointFinderBase.prototype.</span>findPath
            <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.PathFinding">module pathfinding.PathFinding</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.AStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>AStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.BestFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BestFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.BiAStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiAStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.BiBestFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiBestFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.BiBreadthFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiBreadthFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.BiDijkstraFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiDijkstraFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.BreadthFirstFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BreadthFirstFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.DijkstraFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>DijkstraFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.Grid">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Grid
            <span class="apidocSignatureSpan">(width_or_matrix, height, matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.Heap">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Heap
            <span class="apidocSignatureSpan">(cmp)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.IDAStarFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>IDAStarFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.JumpPointFinder">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>JumpPointFinder
            <span class="apidocSignatureSpan">(opt)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.PathFinding.Node">
            function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Node
            <span class="apidocSignatureSpan">(x, y, walkable)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>DiagonalMovement</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Heuristic</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.Util">module pathfinding.Util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.backtrace">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>backtrace
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.biBacktrace">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>biBacktrace
            <span class="apidocSignatureSpan">(nodeA, nodeB)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.compressPath">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>compressPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.expandPath">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>expandPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.interpolate">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>interpolate
            <span class="apidocSignatureSpan">(x0, y0, x1, y1)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.pathLength">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>pathLength
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.Util.smoothenPath">
            function <span class="apidocSignatureSpan">pathfinding.Util.</span>smoothenPath
            <span class="apidocSignatureSpan">(grid, path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.parse_map">module pathfinding.parse_map</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.parse_map.parse">
            function <span class="apidocSignatureSpan">pathfinding.parse_map.</span>parse
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.pathfinding.parse_scen">module pathfinding.parse_scen</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.pathfinding.parse_scen.parse">
            function <span class="apidocSignatureSpan">pathfinding.parse_scen.</span>parse
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding" id="apidoc.module.pathfinding">module pathfinding</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.AStarFinder" id="apidoc.element.pathfinding.AStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>AStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The prefix `Bi` for the last four finders in the above list stands for the bi-directional searching strategy.

Also, Note that only the finders with trailing asterisks are guaranteed to find the shortest path.

To build a path-finder, say, the `AStarFinder`:

```javascript
var finder = new PF.<span class="apidocCodeKeywordSpan">AStarFinder</span>();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.findPath(1, 2, 4, 2, grid);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BestFirstFinder" id="apidoc.element.pathfinding.BestFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BestFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    heuristic: PF.Heuristic.chebyshev
});
```

To build a `BestFirstFinder` with diagonal movement allowed and a custom heuristic function:

```javascript
var finder = new PF.<span class="apidocCodeKeywordSpan">BestFirstFinder</span>({
    allowDiagonal: true,
    heuristic: function(dx, dy) {
        return Math.min(dx, dy);
    }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BiAStarFinder" id="apidoc.element.pathfinding.BiAStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiAStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* parseInt returns NaN (which is falsy) if the string can't be parsed */
weight = parseInt($('#astar_section .spinner').val()) || 1;
weight = weight &gt;= 1 ? weight : 1; /* if negative or 0, use 1 */

heuristic = $('input[name=astar_heuristic]:checked').val();
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiAStarFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners,
        heuristic: PF.Heuristic[heuristic],
        weight: weight
    });
} else {
    finder = new PF.AStarFinder({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BiBestFirstFinder" id="apidoc.element.pathfinding.BiBestFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiBestFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#bestfirst_section ' +
                         '.bi-directional:checked').val() !== 'undefined';
dontCrossCorners = typeof $('#bestfirst_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
heuristic = $('input[name=bestfirst_heuristic]:checked').val();
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiBestFirstFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners,
        heuristic: PF.Heuristic[heuristic]
    });
} else {
    finder = new PF.BestFirstFinder({
        allowDiagonal: allowDiagonal,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BiBreadthFirstFinder" id="apidoc.element.pathfinding.BiBreadthFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiBreadthFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
allowDiagonal = typeof $('#breadthfirst_section ' +
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#breadthfirst_section ' +
                         '.bi-directional:checked').val() !== 'undefined';
dontCrossCorners = typeof $('#breadthfirst_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiBreadthFirstFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
    });
} else {
    finder = new PF.BreadthFirstFinder({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BiDijkstraFinder" id="apidoc.element.pathfinding.BiDijkstraFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiDijkstraFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
allowDiagonal = typeof $('#dijkstra_section ' +
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#dijkstra_section ' +
                         '.bi-directional:checked').val() !=='undefined';
dontCrossCorners = typeof $('#dijkstra_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiDijkstraFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
    });
} else {
    finder = new PF.DijkstraFinder({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BreadthFirstFinder" id="apidoc.element.pathfinding.BreadthFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BreadthFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                             '.dont_cross_corners:checked').val() !=='undefined';
    if (biDirectional) {
        finder = new PF.BiBreadthFirstFinder({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    } else {
        finder = new PF.<span class="apidocCodeKeywordSpan">BreadthFirstFinder</span>({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    }
    break;

case 'bestfirst_header':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.DijkstraFinder" id="apidoc.element.pathfinding.DijkstraFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>DijkstraFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                             '.dont_cross_corners:checked').val() !=='undefined';
    if (biDirectional) {
        finder = new PF.BiDijkstraFinder({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    } else {
        finder = new PF.<span class="apidocCodeKeywordSpan">DijkstraFinder</span>({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    }
    break;

case 'jump_point_header':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid" id="apidoc.element.pathfinding.Grid">
        function <span class="apidocSignatureSpan">pathfinding.</span>Grid
        <span class="apidocSignatureSpan">(width_or_matrix, height, matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Basic Usage
-----------

To build a grid-map of width 5 and height 3:

```javascript
var grid = new PF.<span class="apidocCodeKeywordSpan">Grid</span>(5, 3);
```

By default, all the nodes in the grid will be able to be walked through.
To set whether a node at a given coordinate is walkable or not, use the `setWalkableAt` method.

For example, to set the node at (0, 1) to be un-walkable, where 0 is the x coordinate (from left to right), and
1 is the y coordinate (from up to down):
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap" id="apidoc.element.pathfinding.Heap">
        function <span class="apidocSignatureSpan">pathfinding.</span>Heap
        <span class="apidocSignatureSpan">(cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(cmp) {
  this.cmp = cmp != null ? cmp : defaultCmp;
  this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.IDAStarFinder" id="apidoc.element.pathfinding.IDAStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>IDAStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    // admissible, it should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
weight = weight &gt;= 1 ? weight : 1; /* if negative or 0, use 1 */

timeLimit = parseInt($('#ida_section input[name=time_limit]').val());

// Any non-negative integer, indicates "forever".
timeLimit = (timeLimit &lt;= 0 || isNaN(timeLimit)) ? -1 : timeLimit;

finder = new PF.<span class="apidocCodeKeywordSpan">IDAStarFinder</span>({
  timeLimit: timeLimit,
  trackRecursion: trackRecursion,
  allowDiagonal: allowDiagonal,
  dontCrossCorners: dontCrossCorners,
  heuristic: PF.Heuristic[heuristic],
  weight: weight
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally" id="apidoc.element.pathfinding.JPFAlwaysMoveDiagonally">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFAlwaysMoveDiagonally
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfAtMostOneObstacle
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfNoObstacles
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally" id="apidoc.element.pathfinding.JPFNeverMoveDiagonally">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFNeverMoveDiagonally
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JumpPointFinder" id="apidoc.element.pathfinding.JumpPointFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JumpPointFinder(opt) {
    opt = opt || {};
    if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
    } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;

case 'jump_point_header':
    trackRecursion = typeof $('#jump_point_section ' +
                             '.track_recursion:checked').val() !== 'undefined';
    heuristic = $('input[name=jump_point_heuristic]:checked').val();

    finder = new PF.<span class="apidocCodeKeywordSpan">JumpPointFinder</span>({
      trackJumpRecursion: trackRecursion,
      heuristic: PF.Heuristic[heuristic],
      diagonalMovement: PF.DiagonalMovement.IfAtMostOneObstacle
    });
    break;
case 'orth_jump_point_header':
    trackRecursion = typeof $('#orth_jump_point_section ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JumpPointFinderBase" id="apidoc.element.pathfinding.JumpPointFinderBase">
        function <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinderBase
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JumpPointFinderBase(opt) {
    opt = opt || {};
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.trackJumpRecursion = opt.trackJumpRecursion || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Node" id="apidoc.element.pathfinding.Node">
        function <span class="apidocSignatureSpan">pathfinding.</span>Node
        <span class="apidocSignatureSpan">(x, y, walkable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.AStarFinder" id="apidoc.module.pathfinding.AStarFinder">module pathfinding.AStarFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.AStarFinder.AStarFinder" id="apidoc.element.pathfinding.AStarFinder.AStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>AStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The prefix `Bi` for the last four finders in the above list stands for the bi-directional searching strategy.

Also, Note that only the finders with trailing asterisks are guaranteed to find the shortest path.

To build a path-finder, say, the `AStarFinder`:

```javascript
var finder = new PF.<span class="apidocCodeKeywordSpan">AStarFinder</span>();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.findPath(1, 2, 4, 2, grid);
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.AStarFinder.prototype" id="apidoc.module.pathfinding.AStarFinder.prototype">module pathfinding.AStarFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.AStarFinder.prototype.findPath" id="apidoc.element.pathfinding.AStarFinder.prototype.findPath">
        function <span class="apidocSignatureSpan">pathfinding.AStarFinder.prototype.</span>findPath
        <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPath = function (startX, startY, endX, endY, grid) {
    var openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng;

    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        // if reached the end position, construct the path and return it
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i &lt; l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng &lt; neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    openList.push(neighbor);
                    neighbor.opened = true;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    openList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var finder = new PF.AStarFinder();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.<span class="apidocCodeKeywordSpan">findPath</span>(1, 2, 4, 2, grid);
```

`path` will be an array of coordinates including both the start and end positions.

For the `matrix` defined previously, the `path` will be:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BestFirstFinder" id="apidoc.module.pathfinding.BestFirstFinder">module pathfinding.BestFirstFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BestFirstFinder.BestFirstFinder" id="apidoc.element.pathfinding.BestFirstFinder.BestFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BestFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    heuristic: PF.Heuristic.chebyshev
});
```

To build a `BestFirstFinder` with diagonal movement allowed and a custom heuristic function:

```javascript
var finder = new PF.<span class="apidocCodeKeywordSpan">BestFirstFinder</span>({
    allowDiagonal: true,
    heuristic: function(dx, dy) {
        return Math.min(dx, dy);
    }
});
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BestFirstFinder.prototype" id="apidoc.module.pathfinding.BestFirstFinder.prototype">module pathfinding.BestFirstFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BestFirstFinder.prototype.constructor" id="apidoc.element.pathfinding.BestFirstFinder.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.BestFirstFinder.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BestFirstFinder.prototype.heuristic" id="apidoc.element.pathfinding.BestFirstFinder.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.BestFirstFinder.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiAStarFinder" id="apidoc.module.pathfinding.BiAStarFinder">module pathfinding.BiAStarFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiAStarFinder.BiAStarFinder" id="apidoc.element.pathfinding.BiAStarFinder.BiAStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiAStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* parseInt returns NaN (which is falsy) if the string can't be parsed */
weight = parseInt($('#astar_section .spinner').val()) || 1;
weight = weight &gt;= 1 ? weight : 1; /* if negative or 0, use 1 */

heuristic = $('input[name=astar_heuristic]:checked').val();
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiAStarFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners,
        heuristic: PF.Heuristic[heuristic],
        weight: weight
    });
} else {
    finder = new PF.AStarFinder({
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiAStarFinder.prototype" id="apidoc.module.pathfinding.BiAStarFinder.prototype">module pathfinding.BiAStarFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiAStarFinder.prototype.findPath" id="apidoc.element.pathfinding.BiAStarFinder.prototype.findPath">
        function <span class="apidocSignatureSpan">pathfinding.BiAStarFinder.prototype.</span>findPath
        <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPath = function (startX, startY, endX, endY, grid) {
    var cmp = function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        },
        startOpenList = new Heap(cmp),
        endOpenList = new Heap(cmp),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng,
        BY_START = 1, BY_END = 2;

    // set the `g` and `f` value of the start node to be 0
    // and push it into the start open list
    startNode.g = 0;
    startNode.f = 0;
    startOpenList.push(startNode);
    startNode.opened = BY_START;

    // set the `g` and `f` value of the end node to be 0
    // and push it into the open open list
    endNode.g = 0;
    endNode.f = 0;
    endOpenList.push(endNode);
    endNode.opened = BY_END;

    // while both the open lists are not empty
    while (!startOpenList.empty() &amp;&amp; !endOpenList.empty()) {

        // pop the position of start node which has the minimum `f` value.
        node = startOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i &lt; l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_END) {
                return Util.biBacktrace(node, neighbor);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng &lt; neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    startOpenList.push(neighbor);
                    neighbor.opened = BY_START;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    startOpenList.updateItem(neighbor);
                }
            }
        } // end for each neighbor


        // pop the position of end node which has the minimum `f` value.
        node = endOpenList.pop();
        node.closed = true;

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i &lt; l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened === BY_START) {
                return Util.biBacktrace(neighbor, node);
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng &lt; neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h ||
                    weight * heuristic(abs(x - startX), abs(y - startY));
                neighbor.f = neighbor.g + neighbor.h;
                ne ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var finder = new PF.AStarFinder();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.<span class="apidocCodeKeywordSpan">findPath</span>(1, 2, 4, 2, grid);
```

`path` will be an array of coordinates including both the start and end positions.

For the `matrix` defined previously, the `path` will be:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiBestFirstFinder" id="apidoc.module.pathfinding.BiBestFirstFinder">module pathfinding.BiBestFirstFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiBestFirstFinder.BiBestFirstFinder" id="apidoc.element.pathfinding.BiBestFirstFinder.BiBestFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiBestFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#bestfirst_section ' +
                         '.bi-directional:checked').val() !== 'undefined';
dontCrossCorners = typeof $('#bestfirst_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
heuristic = $('input[name=bestfirst_heuristic]:checked').val();
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiBestFirstFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners,
        heuristic: PF.Heuristic[heuristic]
    });
} else {
    finder = new PF.BestFirstFinder({
        allowDiagonal: allowDiagonal,
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiBestFirstFinder.prototype" id="apidoc.module.pathfinding.BiBestFirstFinder.prototype">module pathfinding.BiBestFirstFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiBestFirstFinder.prototype.constructor" id="apidoc.element.pathfinding.BiBestFirstFinder.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.BiBestFirstFinder.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BiBestFirstFinder.prototype.heuristic" id="apidoc.element.pathfinding.BiBestFirstFinder.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.BiBestFirstFinder.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiBreadthFirstFinder" id="apidoc.module.pathfinding.BiBreadthFirstFinder">module pathfinding.BiBreadthFirstFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiBreadthFirstFinder.BiBreadthFirstFinder" id="apidoc.element.pathfinding.BiBreadthFirstFinder.BiBreadthFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiBreadthFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
allowDiagonal = typeof $('#breadthfirst_section ' +
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#breadthfirst_section ' +
                         '.bi-directional:checked').val() !== 'undefined';
dontCrossCorners = typeof $('#breadthfirst_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiBreadthFirstFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
    });
} else {
    finder = new PF.BreadthFirstFinder({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiBreadthFirstFinder.prototype" id="apidoc.module.pathfinding.BiBreadthFirstFinder.prototype">module pathfinding.BiBreadthFirstFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiBreadthFirstFinder.prototype.findPath" id="apidoc.element.pathfinding.BiBreadthFirstFinder.prototype.findPath">
        function <span class="apidocSignatureSpan">pathfinding.BiBreadthFirstFinder.prototype.</span>findPath
        <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPath = function (startX, startY, endX, endY, grid) {
    var startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        startOpenList = [], endOpenList = [],
        neighbors, neighbor, node,
        diagonalMovement = this.diagonalMovement,
        BY_START = 0, BY_END = 1,
        i, l;

    // push the start and end nodes into the queues
    startOpenList.push(startNode);
    startNode.opened = true;
    startNode.by = BY_START;

    endOpenList.push(endNode);
    endNode.opened = true;
    endNode.by = BY_END;

    // while both the queues are not empty
    while (startOpenList.length &amp;&amp; endOpenList.length) {

        // expand start open list

        node = startOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i &lt; l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                // if this node has been inspected by the reversed search,
                // then a path is found.
                if (neighbor.by === BY_END) {
                    return Util.biBacktrace(node, neighbor);
                }
                continue;
            }
            startOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_START;
        }

        // expand end open list

        node = endOpenList.shift();
        node.closed = true;

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i &lt; l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }
            if (neighbor.opened) {
                if (neighbor.by === BY_START) {
                    return Util.biBacktrace(neighbor, node);
                }
                continue;
            }
            endOpenList.push(neighbor);
            neighbor.parent = node;
            neighbor.opened = true;
            neighbor.by = BY_END;
        }
    }

    // fail to find the path
    return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var finder = new PF.AStarFinder();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.<span class="apidocCodeKeywordSpan">findPath</span>(1, 2, 4, 2, grid);
```

`path` will be an array of coordinates including both the start and end positions.

For the `matrix` defined previously, the `path` will be:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiDijkstraFinder" id="apidoc.module.pathfinding.BiDijkstraFinder">module pathfinding.BiDijkstraFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiDijkstraFinder.BiDijkstraFinder" id="apidoc.element.pathfinding.BiDijkstraFinder.BiDijkstraFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BiDijkstraFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
allowDiagonal = typeof $('#dijkstra_section ' +
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#dijkstra_section ' +
                         '.bi-directional:checked').val() !=='undefined';
dontCrossCorners = typeof $('#dijkstra_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiDijkstraFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
    });
} else {
    finder = new PF.DijkstraFinder({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BiDijkstraFinder.prototype" id="apidoc.module.pathfinding.BiDijkstraFinder.prototype">module pathfinding.BiDijkstraFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BiDijkstraFinder.prototype.constructor" id="apidoc.element.pathfinding.BiDijkstraFinder.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.BiDijkstraFinder.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.BiDijkstraFinder.prototype.heuristic" id="apidoc.element.pathfinding.BiDijkstraFinder.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.BiDijkstraFinder.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BreadthFirstFinder" id="apidoc.module.pathfinding.BreadthFirstFinder">module pathfinding.BreadthFirstFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BreadthFirstFinder.BreadthFirstFinder" id="apidoc.element.pathfinding.BreadthFirstFinder.BreadthFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>BreadthFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                             '.dont_cross_corners:checked').val() !=='undefined';
    if (biDirectional) {
        finder = new PF.BiBreadthFirstFinder({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    } else {
        finder = new PF.<span class="apidocCodeKeywordSpan">BreadthFirstFinder</span>({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    }
    break;

case 'bestfirst_header':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.BreadthFirstFinder.prototype" id="apidoc.module.pathfinding.BreadthFirstFinder.prototype">module pathfinding.BreadthFirstFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.BreadthFirstFinder.prototype.findPath" id="apidoc.element.pathfinding.BreadthFirstFinder.prototype.findPath">
        function <span class="apidocSignatureSpan">pathfinding.BreadthFirstFinder.prototype.</span>findPath
        <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPath = function (startX, startY, endX, endY, grid) {
    var openList = [],
        diagonalMovement = this.diagonalMovement,
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        neighbors, neighbor, node, i, l;

    // push the start pos into the queue
    openList.push(startNode);
    startNode.opened = true;

    // while the queue is not empty
    while (openList.length) {
        // take the front node from the queue
        node = openList.shift();
        node.closed = true;

        // reached the end position
        if (node === endNode) {
            return Util.backtrace(endNode);
        }

        neighbors = grid.getNeighbors(node, diagonalMovement);
        for (i = 0, l = neighbors.length; i &lt; l; ++i) {
            neighbor = neighbors[i];

            // skip this neighbor if it has been inspected before
            if (neighbor.closed || neighbor.opened) {
                continue;
            }

            openList.push(neighbor);
            neighbor.opened = true;
            neighbor.parent = node;
        }
    }

    // fail to find the path
    return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var finder = new PF.AStarFinder();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.<span class="apidocCodeKeywordSpan">findPath</span>(1, 2, 4, 2, grid);
```

`path` will be an array of coordinates including both the start and end positions.

For the `matrix` defined previously, the `path` will be:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.DijkstraFinder" id="apidoc.module.pathfinding.DijkstraFinder">module pathfinding.DijkstraFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.DijkstraFinder.DijkstraFinder" id="apidoc.element.pathfinding.DijkstraFinder.DijkstraFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>DijkstraFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                             '.dont_cross_corners:checked').val() !=='undefined';
    if (biDirectional) {
        finder = new PF.BiDijkstraFinder({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    } else {
        finder = new PF.<span class="apidocCodeKeywordSpan">DijkstraFinder</span>({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    }
    break;

case 'jump_point_header':
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.DijkstraFinder.prototype" id="apidoc.module.pathfinding.DijkstraFinder.prototype">module pathfinding.DijkstraFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.DijkstraFinder.prototype.constructor" id="apidoc.element.pathfinding.DijkstraFinder.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.DijkstraFinder.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.DijkstraFinder.prototype.heuristic" id="apidoc.element.pathfinding.DijkstraFinder.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.DijkstraFinder.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.Grid" id="apidoc.module.pathfinding.Grid">module pathfinding.Grid</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.Grid.Grid" id="apidoc.element.pathfinding.Grid.Grid">
        function <span class="apidocSignatureSpan">pathfinding.</span>Grid
        <span class="apidocSignatureSpan">(width_or_matrix, height, matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Basic Usage
-----------

To build a grid-map of width 5 and height 3:

```javascript
var grid = new PF.<span class="apidocCodeKeywordSpan">Grid</span>(5, 3);
```

By default, all the nodes in the grid will be able to be walked through.
To set whether a node at a given coordinate is walkable or not, use the `setWalkableAt` method.

For example, to set the node at (0, 1) to be un-walkable, where 0 is the x coordinate (from left to right), and
1 is the y coordinate (from up to down):
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.Grid.prototype" id="apidoc.module.pathfinding.Grid.prototype">module pathfinding.Grid.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype._buildNodes" id="apidoc.element.pathfinding.Grid.prototype._buildNodes">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>_buildNodes
        <span class="apidocSignatureSpan">(width, height, matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_buildNodes = function (width, height, matrix) {
    var i, j,
        nodes = new Array(height);

    for (i = 0; i &lt; height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j &lt; width; ++j) {
            nodes[i][j] = new Node(j, i);
        }
    }


    if (matrix === undefined) {
        return nodes;
    }

    if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error('Matrix size does not fit');
    }

    for (i = 0; i &lt; height; ++i) {
        for (j = 0; j &lt; width; ++j) {
            if (matrix[i][j]) {
                // 0, false, null will be walkable
                // while others will be un-walkable
                nodes[i][j].walkable = false;
            }
        }
    }

    return nodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype.clone" id="apidoc.element.pathfinding.Grid.prototype.clone">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
    var i, j,

        width = this.width,
        height = this.height,
        thisNodes = this.nodes,

        newGrid = new Grid(width, height),
        newNodes = new Array(height);

    for (i = 0; i &lt; height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j &lt; width; ++j) {
            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
    }

    newGrid.nodes = newNodes;

    return newGrid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
[ [ 1, 2 ], [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 3, 2 ], [ 4, 2 ] ]
```

Be aware that `grid` will be modified in each path-finding, and will not be usable afterwards. If you want to use a single grid
multiple times, create a clone for it before calling `findPath`.

```javascript
var gridBackup = grid.<span class="apidocCodeKeywordSpan">clone</span>();
```


Advanced Usage
--------------

When instantiating path-finders, you may pass in additional parameters to indicate which specific strategies to use.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype.getNeighbors" id="apidoc.element.pathfinding.Grid.prototype.getNeighbors">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>getNeighbors
        <span class="apidocSignatureSpan">(node, diagonalMovement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNeighbors = function (node, diagonalMovement) {
    var x = node.x,
        y = node.y,
        neighbors = [],
        s0 = false, d0 = false,
        s1 = false, d1 = false,
        s2 = false, d2 = false,
        s3 = false, d3 = false,
        nodes = this.nodes;

    // 
    if (this.isWalkableAt(x, y - 1)) {
        neighbors.push(nodes[y - 1][x]);
        s0 = true;
    }
    // 
    if (this.isWalkableAt(x + 1, y)) {
        neighbors.push(nodes[y][x + 1]);
        s1 = true;
    }
    // 
    if (this.isWalkableAt(x, y + 1)) {
        neighbors.push(nodes[y + 1][x]);
        s2 = true;
    }
    // 
    if (this.isWalkableAt(x - 1, y)) {
        neighbors.push(nodes[y][x - 1]);
        s3 = true;
    }

    if (diagonalMovement === DiagonalMovement.Never) {
        return neighbors;
    }

    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        d0 = s3 &amp;&amp; s0;
        d1 = s0 &amp;&amp; s1;
        d2 = s1 &amp;&amp; s2;
        d3 = s2 &amp;&amp; s3;
    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {
        d0 = s3 || s0;
        d1 = s0 || s1;
        d2 = s1 || s2;
        d3 = s2 || s3;
    } else if (diagonalMovement === DiagonalMovement.Always) {
        d0 = true;
        d1 = true;
        d2 = true;
        d3 = true;
    } else {
        throw new Error('Incorrect value of diagonalMovement');
    }

    // 
    if (d0 &amp;&amp; this.isWalkableAt(x - 1, y - 1)) {
        neighbors.push(nodes[y - 1][x - 1]);
    }
    // 
    if (d1 &amp;&amp; this.isWalkableAt(x + 1, y - 1)) {
        neighbors.push(nodes[y - 1][x + 1]);
    }
    // 
    if (d2 &amp;&amp; this.isWalkableAt(x + 1, y + 1)) {
        neighbors.push(nodes[y + 1][x + 1]);
    }
    // 
    if (d3 &amp;&amp; this.isWalkableAt(x - 1, y + 1)) {
        neighbors.push(nodes[y + 1][x - 1]);
    }

    return neighbors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                neighbors.push([x + dx, y - 1]);
            }
        }
    }
}
// return all neighbors
else {
    neighborNodes = grid.<span class="apidocCodeKeywordSpan">getNeighbors</span>(node, DiagonalMovement.Always);
    for (i = 0, l = neighborNodes.length; i &lt; l; ++i) {
        neighborNode = neighborNodes[i];
        neighbors.push([neighborNode.x, neighborNode.y]);
    }
}

return neighbors;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype.getNodeAt" id="apidoc.element.pathfinding.Grid.prototype.getNodeAt">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>getNodeAt
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNodeAt = function (x, y) {
    return this.nodes[y][x];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    dx = x - px, dy = y - py;

if (!grid.isWalkableAt(x, y)) {
    return null;
}

if(this.trackJumpRecursion === true) {
    grid.<span class="apidocCodeKeywordSpan">getNodeAt</span>(x, y).tested = true;
}

if (grid.getNodeAt(x, y) === this.endNode) {
    return [x, y];
}

// check for forced neighbors
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype.isInside" id="apidoc.element.pathfinding.Grid.prototype.isInside">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>isInside
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInside = function (x, y) {
    return (x &gt;= 0 &amp;&amp; x &lt; this.width) &amp;&amp; (y &gt;= 0 &amp;&amp; y &lt; this.height);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype.isWalkableAt" id="apidoc.element.pathfinding.Grid.prototype.isWalkableAt">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>isWalkableAt
        <span class="apidocSignatureSpan">(x, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWalkableAt = function (x, y) {
    return this.isInside(x, y) &amp;&amp; this.nodes[y][x].walkable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Array&lt;Array&lt;number&gt;&gt;} The x, y coordinate of the jump point
 *     found, or null if not found
 */
JPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {
var grid = this.grid,
    dx = x - px, dy = y - py;

if (!grid.<span class="apidocCodeKeywordSpan">isWalkableAt</span>(x, y)) {
    return null;
}

if(this.trackJumpRecursion === true) {
    grid.getNodeAt(x, y).tested = true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Grid.prototype.setWalkableAt" id="apidoc.element.pathfinding.Grid.prototype.setWalkableAt">
        function <span class="apidocSignatureSpan">pathfinding.Grid.prototype.</span>setWalkableAt
        <span class="apidocSignatureSpan">(x, y, walkable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setWalkableAt = function (x, y, walkable) {
    this.nodes[y][x].walkable = walkable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
By default, all the nodes in the grid will be able to be walked through.
To set whether a node at a given coordinate is walkable or not, use the `setWalkableAt` method.

For example, to set the node at (0, 1) to be un-walkable, where 0 is the x coordinate (from left to right), and
1 is the y coordinate (from up to down):

```javascript
grid.<span class="apidocCodeKeywordSpan">setWalkableAt</span>(0, 1, false);
```

You may also pass in a matrix while instantiating the `PF.Grid` class.
It will initiate all the nodes in the grid with the same walkability indicated by the matrix.
0 for walkable while 1 for blocked.

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.Heap" id="apidoc.module.pathfinding.Heap">module pathfinding.Heap</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.Heap.Heap" id="apidoc.element.pathfinding.Heap.Heap">
        function <span class="apidocSignatureSpan">pathfinding.</span>Heap
        <span class="apidocSignatureSpan">(cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(cmp) {
  this.cmp = cmp != null ? cmp : defaultCmp;
  this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.heapify" id="apidoc.element.pathfinding.Heap.heapify">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>heapify
        <span class="apidocSignatureSpan">(array, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function (array, cmp) {
  var i, _i, _j, _len, _ref, _ref1, _results, _results1;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  _ref1 = (function() {
    _results1 = [];
    for (var _j = 0, _ref = floor(array.length / 2); 0 &lt;= _ref ? _j &lt; _ref : _j &gt; _ref; 0 &lt;= _ref ? _j++ : _j--){ _results1.push
(_j); }
    return _results1;
  }).apply(this).reverse();
  _results = [];
  for (_i = 0, _len = _ref1.length; _i &lt; _len; _i++) {
    i = _ref1[_i];
    _results.push(_siftup(array, i, cmp));
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.nlargest" id="apidoc.element.pathfinding.Heap.nlargest">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>nlargest
        <span class="apidocSignatureSpan">(array, n, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nlargest = function (array, n, cmp) {
  var elem, result, _i, _len, _ref;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  result = array.slice(0, n);
  if (!result.length) {
    return result;
  }
  heapify(result, cmp);
  _ref = array.slice(n);
  for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
    elem = _ref[_i];
    heappushpop(result, elem, cmp);
  }
  return result.sort(cmp).reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.nsmallest" id="apidoc.element.pathfinding.Heap.nsmallest">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>nsmallest
        <span class="apidocSignatureSpan">(array, n, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nsmallest = function (array, n, cmp) {
  var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  if (n * 10 &lt;= array.length) {
    result = array.slice(0, n).sort(cmp);
    if (!result.length) {
      return result;
    }
    los = result[result.length - 1];
    _ref = array.slice(n);
    for (_i = 0, _len = _ref.length; _i &lt; _len; _i++) {
      elem = _ref[_i];
      if (cmp(elem, los) &lt; 0) {
        insort(result, elem, 0, null, cmp);
        result.pop();
        los = result[result.length - 1];
      }
    }
    return result;
  }
  heapify(array, cmp);
  _results = [];
  for (i = _j = 0, _ref1 = min(n, array.length); 0 &lt;= _ref1 ? _j &lt; _ref1 : _j &gt; _ref1; i = 0 &lt;= _ref1 ? ++_j : --_j) {
    _results.push(heappop(array, cmp));
  }
  return _results;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.pop" id="apidoc.element.pathfinding.Heap.pop">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>pop
        <span class="apidocSignatureSpan">(array, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function (array, cmp) {
  var lastelt, returnitem;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  lastelt = array.pop();
  if (array.length) {
    returnitem = array[0];
    array[0] = lastelt;
    _siftup(array, 0, cmp);
  } else {
    returnitem = lastelt;
  }
  return returnitem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
// pop the position of node which has the minimum `f` value.
node = openList.<span class="apidocCodeKeywordSpan">pop</span>();
node.closed = true;

if (node === endNode) {
    return Util.expandPath(Util.backtrace(endNode));
}

this._identifySuccessors(node);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.push" id="apidoc.element.pathfinding.Heap.push">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>push
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (array, item, cmp) {
  if (cmp == null) {
    cmp = defaultCmp;
  }
  array.push(item);
  return _siftdown(array, 0, array.length - 1, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var grid = [];
  lines.forEach(function(line) {
    if (!line.length) {
      return;
    }
    var row = [];
    line.split('').forEach(function(char) {
      row.<span class="apidocCodeKeywordSpan">push</span>(char in { '.': 1, 'G': 1 } ? 0 : 1);
    });
    grid.push(row);
  });
  return grid;
}

function splitext(filename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.pushpop" id="apidoc.element.pathfinding.Heap.pushpop">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>pushpop
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushpop = function (array, item, cmp) {
  var _ref;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  if (array.length &amp;&amp; cmp(array[0], item) &lt; 0) {
    _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
    _siftup(array, 0, cmp);
  }
  return item;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.replace" id="apidoc.element.pathfinding.Heap.replace">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>replace
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (array, item, cmp) {
  var returnitem;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  returnitem = array[0];
  array[0] = item;
  _siftup(array, 0, cmp);
  return returnitem;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.updateItem" id="apidoc.element.pathfinding.Heap.updateItem">
        function <span class="apidocSignatureSpan">pathfinding.Heap.</span>updateItem
        <span class="apidocSignatureSpan">(array, item, cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateItem = function (array, item, cmp) {
  var pos;
  if (cmp == null) {
    cmp = defaultCmp;
  }
  pos = array.indexOf(item);
  if (pos === -1) {
    return;
  }
  _siftdown(array, 0, pos, cmp);
  return _siftup(array, pos, cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.<span class="apidocCodeKeywordSpan">updateItem</span>(jumpNode);
                }
            }
        }
    }
};

module.exports = JumpPointFinderBase;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.Heap.prototype" id="apidoc.module.pathfinding.Heap.prototype">module pathfinding.Heap.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.clear" id="apidoc.element.pathfinding.Heap.prototype.clear">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
  return this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.clone" id="apidoc.element.pathfinding.Heap.prototype.clone">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var heap;
  heap = new Heap();
  heap.nodes = this.nodes.slice(0);
  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
[ [ 1, 2 ], [ 1, 1 ], [ 2, 1 ], [ 3, 1 ], [ 3, 2 ], [ 4, 2 ] ]
```

Be aware that `grid` will be modified in each path-finding, and will not be usable afterwards. If you want to use a single grid
multiple times, create a clone for it before calling `findPath`.

```javascript
var gridBackup = grid.<span class="apidocCodeKeywordSpan">clone</span>();
```


Advanced Usage
--------------

When instantiating path-finders, you may pass in additional parameters to indicate which specific strategies to use.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.contains" id="apidoc.element.pathfinding.Heap.prototype.contains">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>contains
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contains = function (x) {
  return this.nodes.indexOf(x) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.copy" id="apidoc.element.pathfinding.Heap.prototype.copy">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>copy
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">copy = function () {
  var heap;
  heap = new Heap();
  heap.nodes = this.nodes.slice(0);
  return heap;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.empty" id="apidoc.element.pathfinding.Heap.prototype.empty">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>empty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">empty = function () {
  return this.nodes.length === 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.<span class="apidocCodeKeywordSpan">empty</span>()) {
// pop the position of node which has the minimum `f` value.
node = openList.pop();
node.closed = true;

if (node === endNode) {
    return Util.expandPath(Util.backtrace(endNode));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.front" id="apidoc.element.pathfinding.Heap.prototype.front">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>front
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">front = function () {
  return this.nodes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.has" id="apidoc.element.pathfinding.Heap.prototype.has">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>has
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">has = function (x) {
  return this.nodes.indexOf(x) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.heapify" id="apidoc.element.pathfinding.Heap.prototype.heapify">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>heapify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heapify = function () {
  return heapify(this.nodes, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.insert" id="apidoc.element.pathfinding.Heap.prototype.insert">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>insert
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (x) {
  return heappush(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.peek" id="apidoc.element.pathfinding.Heap.prototype.peek">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>peek
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function () {
  return this.nodes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.pop" id="apidoc.element.pathfinding.Heap.prototype.pop">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>pop
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pop = function () {
  return heappop(this.nodes, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
// pop the position of node which has the minimum `f` value.
node = openList.<span class="apidocCodeKeywordSpan">pop</span>();
node.closed = true;

if (node === endNode) {
    return Util.expandPath(Util.backtrace(endNode));
}

this._identifySuccessors(node);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.push" id="apidoc.element.pathfinding.Heap.prototype.push">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>push
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">push = function (x) {
  return heappush(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var grid = [];
  lines.forEach(function(line) {
    if (!line.length) {
      return;
    }
    var row = [];
    line.split('').forEach(function(char) {
      row.<span class="apidocCodeKeywordSpan">push</span>(char in { '.': 1, 'G': 1 } ? 0 : 1);
    });
    grid.push(row);
  });
  return grid;
}

function splitext(filename) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.pushpop" id="apidoc.element.pathfinding.Heap.prototype.pushpop">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>pushpop
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pushpop = function (x) {
  return heappushpop(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.replace" id="apidoc.element.pathfinding.Heap.prototype.replace">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>replace
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replace = function (x) {
  return heapreplace(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.size" id="apidoc.element.pathfinding.Heap.prototype.size">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>size
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">size = function () {
  return this.nodes.length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.toArray" id="apidoc.element.pathfinding.Heap.prototype.toArray">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>toArray
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toArray = function () {
  return this.nodes.slice(0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.top" id="apidoc.element.pathfinding.Heap.prototype.top">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>top
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">top = function () {
  return this.nodes[0];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heap.prototype.updateItem" id="apidoc.element.pathfinding.Heap.prototype.updateItem">
        function <span class="apidocSignatureSpan">pathfinding.Heap.prototype.</span>updateItem
        <span class="apidocSignatureSpan">(x)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateItem = function (x) {
  return updateItem(this.nodes, x, this.cmp);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.<span class="apidocCodeKeywordSpan">updateItem</span>(jumpNode);
                }
            }
        }
    }
};

module.exports = JumpPointFinderBase;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.Heuristic" id="apidoc.module.pathfinding.Heuristic">module pathfinding.Heuristic</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.Heuristic.chebyshev" id="apidoc.element.pathfinding.Heuristic.chebyshev">
        function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>chebyshev
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">chebyshev = function (dx, dy) {
    return Math.max(dx, dy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heuristic.euclidean" id="apidoc.element.pathfinding.Heuristic.euclidean">
        function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>euclidean
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">euclidean = function (dx, dy) {
    return Math.sqrt(dx * dx + dy * dy);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heuristic.manhattan" id="apidoc.element.pathfinding.Heuristic.manhattan">
        function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>manhattan
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">manhattan = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Heuristic.octile" id="apidoc.element.pathfinding.Heuristic.octile">
        function <span class="apidocSignatureSpan">pathfinding.Heuristic.</span>octile
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">octile = function (dx, dy) {
    var F = Math.SQRT2 - 1;
    return (dx &lt; dy) ? F * dx + dy : F * dy + dx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
jumpNode = grid.getNodeAt(jx, jy);

if (jumpNode.closed) {
    continue;
}

// include distance, as parent may not be immediately adjacent:
d = Heuristic.<span class="apidocCodeKeywordSpan">octile</span>(abs(jx - x), abs(jy - y));
ng = node.g + d; // next `g` value

if (!jumpNode.opened || ng &lt; jumpNode.g) {
    jumpNode.g = ng;
    jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
    jumpNode.f = jumpNode.g + jumpNode.h;
    jumpNode.parent = node;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.IDAStarFinder" id="apidoc.module.pathfinding.IDAStarFinder">module pathfinding.IDAStarFinder</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.IDAStarFinder.IDAStarFinder" id="apidoc.element.pathfinding.IDAStarFinder.IDAStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.</span>IDAStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    // admissible, it should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
weight = weight &gt;= 1 ? weight : 1; /* if negative or 0, use 1 */

timeLimit = parseInt($('#ida_section input[name=time_limit]').val());

// Any non-negative integer, indicates "forever".
timeLimit = (timeLimit &lt;= 0 || isNaN(timeLimit)) ? -1 : timeLimit;

finder = new PF.<span class="apidocCodeKeywordSpan">IDAStarFinder</span>({
  timeLimit: timeLimit,
  trackRecursion: trackRecursion,
  allowDiagonal: allowDiagonal,
  dontCrossCorners: dontCrossCorners,
  heuristic: PF.Heuristic[heuristic],
  weight: weight
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.IDAStarFinder.prototype" id="apidoc.module.pathfinding.IDAStarFinder.prototype">module pathfinding.IDAStarFinder.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.IDAStarFinder.prototype.findPath" id="apidoc.element.pathfinding.IDAStarFinder.prototype.findPath">
        function <span class="apidocSignatureSpan">pathfinding.IDAStarFinder.prototype.</span>findPath
        <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPath = function (startX, startY, endX, endY, grid) {
    // Used for statistics:
    var nodesVisited = 0;

    // Execution time limitation:
    var startTime = new Date().getTime();

    // Heuristic helper:
    var h = function(a, b) {
        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
    }.bind(this);

    // Step cost from a to b:
    var cost = function(a, b) {
        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
    };

    /**
     * IDA* search implementation.
     *
     * @param {Node} The node currently expanding from.
     * @param {number} Cost to reach the given node.
     * @param {number} Maximum search depth (cut-off value).
     * @param {Array&lt;Array&lt;number&gt;&gt;} The found route.
     * @param {number} Recursion depth.
     *
     * @return {Object} either a number with the new optimal cut-off depth,
     * or a valid node instance, in which case a path was found.
     */
    var search = function(node, g, cutoff, route, depth) {
        nodesVisited++;

        // Enforce timelimit:
        if (this.timeLimit &gt; 0 &amp;&amp;
            new Date().getTime() - startTime &gt; this.timeLimit * 1000) {
            // Enforced as "path-not-found".
            return Infinity;
        }

        var f = g + h(node, end) * this.weight;

        // We've searched too deep for this iteration.
        if (f &gt; cutoff) {
            return f;
        }

        if (node == end) {
            route[depth] = [node.x, node.y];
            return node;
        }

        var min, t, k, neighbour;

        var neighbours = grid.getNeighbors(node, this.diagonalMovement);

        // Sort the neighbours, gives nicer paths. But, this deviates
        // from the original algorithm - so I left it out.
        //neighbours.sort(function(a, b){
        //    return h(a, end) - h(b, end);
        //});


        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment
        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment
            if (this.trackRecursion) {
                // Retain a copy for visualisation. Due to recursion, this
                // node may be part of other paths too.
                neighbour.retainCount = neighbour.retainCount + 1 || 1;

                if(neighbour.tested !== true) {
                    neighbour.tested = true;
                }
            }

            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);

            if (t instanceof Node) {
                route[depth] = [node.x, node.y];

                // For a typical A* linked list, this would work:
                // neighbour.parent = node;
                return t;
            }

            // Decrement count, then determine whether it's actually closed.
            if (this.trackRecursion &amp;&amp; (--neighbour.retainCount) === 0) {
                neighbour.tested = false;
            }

            if (t &lt; min) {
                min = t;
            }
        }

        return min;

    }.bind(this);

    // Node instance lookups:
    var start = grid.getNodeAt(startX, startY);
    var end   = grid.getNodeAt(endX, endY);

    // Initial search depth, given the typical heuristic contraints,
    // there should be no cheaper route possible.
    var cutOff = h(start, end);

    var j, route, t;

    // With an overflow protection.
    for (j = 0; true; ++j) {

        route = [];

        // Search till cut-off depth:
        t = search(start, 0, cutOff, route, 0);

        // Route not possible, or not found in time limit.
        if (t === Infinity) {
            return [];
        }

        // If t is a node, it's also the end node. Route is now
        // populated with a valid path to the end node.
        if (t instanceof Node) {
            return route;
        }

        // Try again, this t ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var finder = new PF.AStarFinder();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.<span class="apidocCodeKeywordSpan">findPath</span>(1, 2, 4, 2, grid);
```

`path` will be an array of coordinates including both the start and end positions.

For the `matrix` defined previously, the `path` will be:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFAlwaysMoveDiagonally" id="apidoc.module.pathfinding.JPFAlwaysMoveDiagonally">module pathfinding.JPFAlwaysMoveDiagonally</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.JPFAlwaysMoveDiagonally" id="apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.JPFAlwaysMoveDiagonally">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFAlwaysMoveDiagonally
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFAlwaysMoveDiagonally.prototype" id="apidoc.module.pathfinding.JPFAlwaysMoveDiagonally.prototype">module pathfinding.JPFAlwaysMoveDiagonally.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype._findNeighbors" id="apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype._findNeighbors">
        function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>_findNeighbors
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findNeighbors = function (node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 &amp;&amp; dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x + dx, y + dy)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                }
                if (!grid.isWalkableAt(x + 1, y)) {
                    neighbors.push([x + 1, y + dy]);
                }
                if (!grid.isWalkableAt(x - 1, y)) {
                    neighbors.push([x - 1, y + dy]);
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                }
                if (!grid.isWalkableAt(x, y + 1)) {
                    neighbors.push([x + dx, y + 1]);
                }
                if (!grid.isWalkableAt(x, y - 1)) {
                    neighbors.push([x + dx, y - 1]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
        for (i = 0, l = neighborNodes.length; i &lt; l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this.<span class="apidocCodeKeywordSpan">_findNeighbors</span>(node);
    for(i = 0, l = neighbors.length; i &lt; l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

jx = jumpPoint[0];
jy = jumpPoint[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype._jump" id="apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype._jump">
        function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>_jump
        <span class="apidocSignatureSpan">(x, y, px, py)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_jump = function (x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 &amp;&amp; dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) &amp;&amp; !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) &amp;&amp; !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) &amp;&amp; !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) &amp;&amp; !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    return this._jump(x + dx, y + dy, x, y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// along the diagonal
if (dx !== 0 &amp;&amp; dy !== 0) {
    if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
        (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
        return [x, y];
    }
    // when moving diagonally, must check for vertical/horizontal jump points
    if (this.<span class="apidocCodeKeywordSpan">_jump</span>(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
        return [x, y];
    }
}
// horizontally/vertically
else {
    if( dx !== 0 ) { // moving along x
        if((grid.isWalkableAt(x + dx, y + 1) &amp;&amp; !grid.isWalkableAt(x, y + 1)) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype.constructor" id="apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFAlwaysMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype.heuristic" id="apidoc.element.pathfinding.JPFAlwaysMoveDiagonally.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.JPFAlwaysMoveDiagonally.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle" id="apidoc.module.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle">module pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.JPFMoveDiagonallyIfAtMostOneObstacle" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.JPFMoveDiagonallyIfAtMostOneObstacle">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfAtMostOneObstacle
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype" id="apidoc.module.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype">module pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>_findNeighbors
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findNeighbors = function (node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 &amp;&amp; dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
            if (!grid.isWalkableAt(x - dx, y) &amp;&amp; grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x - dx, y + dy]);
            }
            if (!grid.isWalkableAt(x, y - dy) &amp;&amp; grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y - dy]);
            }
        }
        // search horizontally/vertically
        else {
            if(dx === 0) {
                if (grid.isWalkableAt(x, y + dy)) {
                    neighbors.push([x, y + dy]);
                    if (!grid.isWalkableAt(x + 1, y)) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (!grid.isWalkableAt(x - 1, y)) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
            }
            else {
                if (grid.isWalkableAt(x + dx, y)) {
                    neighbors.push([x + dx, y]);
                    if (!grid.isWalkableAt(x, y + 1)) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (!grid.isWalkableAt(x, y - 1)) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
        for (i = 0, l = neighborNodes.length; i &lt; l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this.<span class="apidocCodeKeywordSpan">_findNeighbors</span>(node);
    for(i = 0, l = neighbors.length; i &lt; l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

jx = jumpPoint[0];
jy = jumpPoint[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>_jump
        <span class="apidocSignatureSpan">(x, y, px, py)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_jump = function (x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 &amp;&amp; dy !== 0) {
        if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
            (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
            return [x, y];
        }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if( dx !== 0 ) { // moving along x
            if((grid.isWalkableAt(x + dx, y + 1) &amp;&amp; !grid.isWalkableAt(x, y + 1)) ||
               (grid.isWalkableAt(x + dx, y - 1) &amp;&amp; !grid.isWalkableAt(x, y - 1))) {
                return [x, y];
            }
        }
        else {
            if((grid.isWalkableAt(x + 1, y + dy) &amp;&amp; !grid.isWalkableAt(x + 1, y)) ||
               (grid.isWalkableAt(x - 1, y + dy) &amp;&amp; !grid.isWalkableAt(x - 1, y))) {
                return [x, y];
            }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// along the diagonal
if (dx !== 0 &amp;&amp; dy !== 0) {
    if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
        (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
        return [x, y];
    }
    // when moving diagonally, must check for vertical/horizontal jump points
    if (this.<span class="apidocCodeKeywordSpan">_jump</span>(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
        return [x, y];
    }
}
// horizontally/vertically
else {
    if( dx !== 0 ) { // moving along x
        if((grid.isWalkableAt(x + dx, y + 1) &amp;&amp; !grid.isWalkableAt(x, y + 1)) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.heuristic" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfAtMostOneObstacle.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfNoObstacles" id="apidoc.module.pathfinding.JPFMoveDiagonallyIfNoObstacles">module pathfinding.JPFMoveDiagonallyIfNoObstacles</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.JPFMoveDiagonallyIfNoObstacles" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.JPFMoveDiagonallyIfNoObstacles">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFMoveDiagonallyIfNoObstacles
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype" id="apidoc.module.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype">module pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>_findNeighbors
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findNeighbors = function (node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        // search diagonally
        if (dx !== 0 &amp;&amp; dy !== 0) {
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
            if (grid.isWalkableAt(x, y + dy) &amp;&amp; grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y + dy]);
            }
        }
        // search horizontally/vertically
        else {
            var isNextWalkable;
            if (dx !== 0) {
                isNextWalkable = grid.isWalkableAt(x + dx, y);
                var isTopWalkable = grid.isWalkableAt(x, y + 1);
                var isBottomWalkable = grid.isWalkableAt(x, y - 1);

                if (isNextWalkable) {
                    neighbors.push([x + dx, y]);
                    if (isTopWalkable) {
                        neighbors.push([x + dx, y + 1]);
                    }
                    if (isBottomWalkable) {
                        neighbors.push([x + dx, y - 1]);
                    }
                }
                if (isTopWalkable) {
                    neighbors.push([x, y + 1]);
                }
                if (isBottomWalkable) {
                    neighbors.push([x, y - 1]);
                }
            }
            else if (dy !== 0) {
                isNextWalkable = grid.isWalkableAt(x, y + dy);
                var isRightWalkable = grid.isWalkableAt(x + 1, y);
                var isLeftWalkable = grid.isWalkableAt(x - 1, y);

                if (isNextWalkable) {
                    neighbors.push([x, y + dy]);
                    if (isRightWalkable) {
                        neighbors.push([x + 1, y + dy]);
                    }
                    if (isLeftWalkable) {
                        neighbors.push([x - 1, y + dy]);
                    }
                }
                if (isRightWalkable) {
                    neighbors.push([x + 1, y]);
                }
                if (isLeftWalkable) {
                    neighbors.push([x - 1, y]);
                }
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
        for (i = 0, l = neighborNodes.length; i &lt; l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this.<span class="apidocCodeKeywordSpan">_findNeighbors</span>(node);
    for(i = 0, l = neighbors.length; i &lt; l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

jx = jumpPoint[0];
jy = jumpPoint[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype._jump" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype._jump">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>_jump
        <span class="apidocSignatureSpan">(x, y, px, py)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_jump = function (x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    // check for forced neighbors
    // along the diagonal
    if (dx !== 0 &amp;&amp; dy !== 0) {
        // if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
            // (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
            // return [x, y];
        // }
        // when moving diagonally, must check for vertical/horizontal jump points
        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
            return [x, y];
        }
    }
    // horizontally/vertically
    else {
        if (dx !== 0) {
            if ((grid.isWalkableAt(x, y - 1) &amp;&amp; !grid.isWalkableAt(x - dx, y - 1)) ||
                (grid.isWalkableAt(x, y + 1) &amp;&amp; !grid.isWalkableAt(x - dx, y + 1))) {
                return [x, y];
            }
        }
        else if (dy !== 0) {
            if ((grid.isWalkableAt(x - 1, y) &amp;&amp; !grid.isWalkableAt(x - 1, y - dy)) ||
                (grid.isWalkableAt(x + 1, y) &amp;&amp; !grid.isWalkableAt(x + 1, y - dy))) {
                return [x, y];
            }
            // When moving vertically, must check for horizontal jump points
            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
                // return [x, y];
            // }
        }
    }

    // moving diagonally, must make sure one of the vertical/horizontal
    // neighbors is open to allow the path
    if (grid.isWalkableAt(x + dx, y) &amp;&amp; grid.isWalkableAt(x, y + dy)) {
        return this._jump(x + dx, y + dy, x, y);
    } else {
        return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// along the diagonal
if (dx !== 0 &amp;&amp; dy !== 0) {
    if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
        (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
        return [x, y];
    }
    // when moving diagonally, must check for vertical/horizontal jump points
    if (this.<span class="apidocCodeKeywordSpan">_jump</span>(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
        return [x, y];
    }
}
// horizontally/vertically
else {
    if( dx !== 0 ) { // moving along x
        if((grid.isWalkableAt(x + dx, y + 1) &amp;&amp; !grid.isWalkableAt(x, y + 1)) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.constructor" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFMoveDiagonallyIfNoObstacles(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.heuristic" id="apidoc.element.pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.JPFMoveDiagonallyIfNoObstacles.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFNeverMoveDiagonally" id="apidoc.module.pathfinding.JPFNeverMoveDiagonally">module pathfinding.JPFNeverMoveDiagonally</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.JPFNeverMoveDiagonally" id="apidoc.element.pathfinding.JPFNeverMoveDiagonally.JPFNeverMoveDiagonally">
        function <span class="apidocSignatureSpan">pathfinding.</span>JPFNeverMoveDiagonally
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JPFNeverMoveDiagonally.prototype" id="apidoc.module.pathfinding.JPFNeverMoveDiagonally.prototype">module pathfinding.JPFNeverMoveDiagonally.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype._findNeighbors" id="apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype._findNeighbors">
        function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>_findNeighbors
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findNeighbors = function (node) {
    var parent = node.parent,
        x = node.x, y = node.y,
        grid = this.grid,
        px, py, nx, ny, dx, dy,
        neighbors = [], neighborNodes, neighborNode, i, l;

    // directed pruning: can ignore most neighbors, unless forced.
    if (parent) {
        px = parent.x;
        py = parent.y;
        // get the normalized direction of travel
        dx = (x - px) / Math.max(Math.abs(x - px), 1);
        dy = (y - py) / Math.max(Math.abs(y - py), 1);

        if (dx !== 0) {
            if (grid.isWalkableAt(x, y - 1)) {
                neighbors.push([x, y - 1]);
            }
            if (grid.isWalkableAt(x, y + 1)) {
                neighbors.push([x, y + 1]);
            }
            if (grid.isWalkableAt(x + dx, y)) {
                neighbors.push([x + dx, y]);
            }
        }
        else if (dy !== 0) {
            if (grid.isWalkableAt(x - 1, y)) {
                neighbors.push([x - 1, y]);
            }
            if (grid.isWalkableAt(x + 1, y)) {
                neighbors.push([x + 1, y]);
            }
            if (grid.isWalkableAt(x, y + dy)) {
                neighbors.push([x, y + dy]);
            }
        }
    }
    // return all neighbors
    else {
        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
        for (i = 0, l = neighborNodes.length; i &lt; l; ++i) {
            neighborNode = neighborNodes[i];
            neighbors.push([neighborNode.x, neighborNode.y]);
        }
    }

    return neighbors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this.<span class="apidocCodeKeywordSpan">_findNeighbors</span>(node);
    for(i = 0, l = neighbors.length; i &lt; l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

jx = jumpPoint[0];
jy = jumpPoint[1];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype._jump" id="apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype._jump">
        function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>_jump
        <span class="apidocSignatureSpan">(x, y, px, py)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_jump = function (x, y, px, py) {
    var grid = this.grid,
        dx = x - px, dy = y - py;

    if (!grid.isWalkableAt(x, y)) {
        return null;
    }

    if(this.trackJumpRecursion === true) {
        grid.getNodeAt(x, y).tested = true;
    }

    if (grid.getNodeAt(x, y) === this.endNode) {
        return [x, y];
    }

    if (dx !== 0) {
        if ((grid.isWalkableAt(x, y - 1) &amp;&amp; !grid.isWalkableAt(x - dx, y - 1)) ||
            (grid.isWalkableAt(x, y + 1) &amp;&amp; !grid.isWalkableAt(x - dx, y + 1))) {
            return [x, y];
        }
    }
    else if (dy !== 0) {
        if ((grid.isWalkableAt(x - 1, y) &amp;&amp; !grid.isWalkableAt(x - 1, y - dy)) ||
            (grid.isWalkableAt(x + 1, y) &amp;&amp; !grid.isWalkableAt(x + 1, y - dy))) {
            return [x, y];
        }
        //When moving vertically, must check for horizontal jump points
        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
            return [x, y];
        }
    }
    else {
        throw new Error("Only horizontal and vertical movements are allowed");
    }

    return this._jump(x + dx, y + dy, x, y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// along the diagonal
if (dx !== 0 &amp;&amp; dy !== 0) {
    if ((grid.isWalkableAt(x - dx, y + dy) &amp;&amp; !grid.isWalkableAt(x - dx, y)) ||
        (grid.isWalkableAt(x + dx, y - dy) &amp;&amp; !grid.isWalkableAt(x, y - dy))) {
        return [x, y];
    }
    // when moving diagonally, must check for vertical/horizontal jump points
    if (this.<span class="apidocCodeKeywordSpan">_jump</span>(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
        return [x, y];
    }
}
// horizontally/vertically
else {
    if( dx !== 0 ) { // moving along x
        if((grid.isWalkableAt(x + dx, y + 1) &amp;&amp; !grid.isWalkableAt(x, y + 1)) ||
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype.constructor" id="apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype.constructor">
        function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>constructor
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JPFNeverMoveDiagonally(opt) {
    JumpPointFinderBase.call(this, opt);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype.heuristic" id="apidoc.element.pathfinding.JPFNeverMoveDiagonally.prototype.heuristic">
        function <span class="apidocSignatureSpan">pathfinding.JPFNeverMoveDiagonally.prototype.</span>heuristic
        <span class="apidocSignatureSpan">(dx, dy)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">heuristic = function (dx, dy) {
    return dx + dy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JumpPointFinderBase" id="apidoc.module.pathfinding.JumpPointFinderBase">module pathfinding.JumpPointFinderBase</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.JumpPointFinderBase.JumpPointFinderBase" id="apidoc.element.pathfinding.JumpPointFinderBase.JumpPointFinderBase">
        function <span class="apidocSignatureSpan">pathfinding.</span>JumpPointFinderBase
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JumpPointFinderBase(opt) {
    opt = opt || {};
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.trackJumpRecursion = opt.trackJumpRecursion || false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.JumpPointFinderBase.prototype" id="apidoc.module.pathfinding.JumpPointFinderBase.prototype">module pathfinding.JumpPointFinderBase.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.JumpPointFinderBase.prototype._identifySuccessors" id="apidoc.element.pathfinding.JumpPointFinderBase.prototype._identifySuccessors">
        function <span class="apidocSignatureSpan">pathfinding.JumpPointFinderBase.prototype.</span>_identifySuccessors
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_identifySuccessors = function (node) {
    var grid = this.grid,
        heuristic = this.heuristic,
        openList = this.openList,
        endX = this.endNode.x,
        endY = this.endNode.y,
        neighbors, neighbor,
        jumpPoint, i, l,
        x = node.x, y = node.y,
        jx, jy, dx, dy, d, ng, jumpNode,
        abs = Math.abs, max = Math.max;

    neighbors = this._findNeighbors(node);
    for(i = 0, l = neighbors.length; i &lt; l; ++i) {
        neighbor = neighbors[i];
        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
        if (jumpPoint) {

            jx = jumpPoint[0];
            jy = jumpPoint[1];
            jumpNode = grid.getNodeAt(jx, jy);

            if (jumpNode.closed) {
                continue;
            }

            // include distance, as parent may not be immediately adjacent:
            d = Heuristic.octile(abs(jx - x), abs(jy - y));
            ng = node.g + d; // next `g` value

            if (!jumpNode.opened || ng &lt; jumpNode.g) {
                jumpNode.g = ng;
                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
                jumpNode.f = jumpNode.g + jumpNode.h;
                jumpNode.parent = node;

                if (!jumpNode.opened) {
                    openList.push(jumpNode);
                    jumpNode.opened = true;
                } else {
                    openList.updateItem(jumpNode);
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        node = openList.pop();
        node.closed = true;

        if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
        }

        this.<span class="apidocCodeKeywordSpan">_identifySuccessors</span>(node);
    }

    // fail to find the path
    return [];
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.JumpPointFinderBase.prototype.findPath" id="apidoc.element.pathfinding.JumpPointFinderBase.prototype.findPath">
        function <span class="apidocSignatureSpan">pathfinding.JumpPointFinderBase.prototype.</span>findPath
        <span class="apidocSignatureSpan">(startX, startY, endX, endY, grid)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findPath = function (startX, startY, endX, endY, grid) {
    var openList = this.openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = this.startNode = grid.getNodeAt(startX, startY),
        endNode = this.endNode = grid.getNodeAt(endX, endY), node;

    this.grid = grid;


    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;

    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;

        if (node === endNode) {
            return Util.expandPath(Util.backtrace(endNode));
        }

        this._identifySuccessors(node);
    }

    // fail to find the path
    return [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var finder = new PF.AStarFinder();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.<span class="apidocCodeKeywordSpan">findPath</span>(1, 2, 4, 2, grid);
```

`path` will be an array of coordinates including both the start and end positions.

For the `matrix` defined previously, the `path` will be:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.PathFinding" id="apidoc.module.pathfinding.PathFinding">module pathfinding.PathFinding</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.AStarFinder" id="apidoc.element.pathfinding.PathFinding.AStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>AStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
The prefix `Bi` for the last four finders in the above list stands for the bi-directional searching strategy.

Also, Note that only the finders with trailing asterisks are guaranteed to find the shortest path.

To build a path-finder, say, the `AStarFinder`:

```javascript
var finder = new PF.<span class="apidocCodeKeywordSpan">AStarFinder</span>();
```

To find a path from (1, 2) to (4, 2), (Note: both the start point and end point should be walkable):

```javascript
var path = finder.findPath(1, 2, 4, 2, grid);
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.BestFirstFinder" id="apidoc.element.pathfinding.PathFinding.BestFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BestFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BestFirstFinder(opt) {
    AStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    heuristic: PF.Heuristic.chebyshev
});
```

To build a `BestFirstFinder` with diagonal movement allowed and a custom heuristic function:

```javascript
var finder = new PF.<span class="apidocCodeKeywordSpan">BestFirstFinder</span>({
    allowDiagonal: true,
    heuristic: function(dx, dy) {
        return Math.min(dx, dy);
    }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.BiAStarFinder" id="apidoc.element.pathfinding.PathFinding.BiAStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiAStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    //When diagonal movement is allowed the manhattan heuristic is not admissible
    //It should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/* parseInt returns NaN (which is falsy) if the string can't be parsed */
weight = parseInt($('#astar_section .spinner').val()) || 1;
weight = weight &gt;= 1 ? weight : 1; /* if negative or 0, use 1 */

heuristic = $('input[name=astar_heuristic]:checked').val();
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiAStarFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners,
        heuristic: PF.Heuristic[heuristic],
        weight: weight
    });
} else {
    finder = new PF.AStarFinder({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.BiBestFirstFinder" id="apidoc.element.pathfinding.PathFinding.BiBestFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiBestFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBestFirstFinder(opt) {
    BiAStarFinder.call(this, opt);

    var orig = this.heuristic;
    this.heuristic = function(dx, dy) {
        return orig(dx, dy) * 1000000;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#bestfirst_section ' +
                         '.bi-directional:checked').val() !== 'undefined';
dontCrossCorners = typeof $('#bestfirst_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
heuristic = $('input[name=bestfirst_heuristic]:checked').val();
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiBestFirstFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners,
        heuristic: PF.Heuristic[heuristic]
    });
} else {
    finder = new PF.BestFirstFinder({
        allowDiagonal: allowDiagonal,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.BiBreadthFirstFinder" id="apidoc.element.pathfinding.PathFinding.BiBreadthFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiBreadthFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiBreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
allowDiagonal = typeof $('#breadthfirst_section ' +
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#breadthfirst_section ' +
                         '.bi-directional:checked').val() !== 'undefined';
dontCrossCorners = typeof $('#breadthfirst_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiBreadthFirstFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
    });
} else {
    finder = new PF.BreadthFirstFinder({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.BiDijkstraFinder" id="apidoc.element.pathfinding.PathFinding.BiDijkstraFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BiDijkstraFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BiDijkstraFinder(opt) {
    BiAStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
allowDiagonal = typeof $('#dijkstra_section ' +
                         '.allow_diagonal:checked').val() !== 'undefined';
biDirectional = typeof $('#dijkstra_section ' +
                         '.bi-directional:checked').val() !=='undefined';
dontCrossCorners = typeof $('#dijkstra_section ' +
                         '.dont_cross_corners:checked').val() !=='undefined';
if (biDirectional) {
    finder = new PF.<span class="apidocCodeKeywordSpan">BiDijkstraFinder</span>({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
    });
} else {
    finder = new PF.DijkstraFinder({
        allowDiagonal: allowDiagonal,
        dontCrossCorners: dontCrossCorners
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.BreadthFirstFinder" id="apidoc.element.pathfinding.PathFinding.BreadthFirstFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>BreadthFirstFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function BreadthFirstFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                             '.dont_cross_corners:checked').val() !=='undefined';
    if (biDirectional) {
        finder = new PF.BiBreadthFirstFinder({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    } else {
        finder = new PF.<span class="apidocCodeKeywordSpan">BreadthFirstFinder</span>({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    }
    break;

case 'bestfirst_header':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.DijkstraFinder" id="apidoc.element.pathfinding.PathFinding.DijkstraFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>DijkstraFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DijkstraFinder(opt) {
    AStarFinder.call(this, opt);
    this.heuristic = function(dx, dy) {
        return 0;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
                             '.dont_cross_corners:checked').val() !=='undefined';
    if (biDirectional) {
        finder = new PF.BiDijkstraFinder({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    } else {
        finder = new PF.<span class="apidocCodeKeywordSpan">DijkstraFinder</span>({
            allowDiagonal: allowDiagonal,
            dontCrossCorners: dontCrossCorners
        });
    }
    break;

case 'jump_point_header':
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.Grid" id="apidoc.element.pathfinding.PathFinding.Grid">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Grid
        <span class="apidocSignatureSpan">(width_or_matrix, height, matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Basic Usage
-----------

To build a grid-map of width 5 and height 3:

```javascript
var grid = new PF.<span class="apidocCodeKeywordSpan">Grid</span>(5, 3);
```

By default, all the nodes in the grid will be able to be walked through.
To set whether a node at a given coordinate is walkable or not, use the `setWalkableAt` method.

For example, to set the node at (0, 1) to be un-walkable, where 0 is the x coordinate (from left to right), and
1 is the y coordinate (from up to down):
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.Heap" id="apidoc.element.pathfinding.PathFinding.Heap">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Heap
        <span class="apidocSignatureSpan">(cmp)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Heap(cmp) {
  this.cmp = cmp != null ? cmp : defaultCmp;
  this.nodes = [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.IDAStarFinder" id="apidoc.element.pathfinding.PathFinding.IDAStarFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>IDAStarFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function IDAStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = opt.allowDiagonal;
    this.dontCrossCorners = opt.dontCrossCorners;
    this.diagonalMovement = opt.diagonalMovement;
    this.heuristic = opt.heuristic || Heuristic.manhattan;
    this.weight = opt.weight || 1;
    this.trackRecursion = opt.trackRecursion || false;
    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.

    if (!this.diagonalMovement) {
        if (!this.allowDiagonal) {
            this.diagonalMovement = DiagonalMovement.Never;
        } else {
            if (this.dontCrossCorners) {
                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
            } else {
                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
            }
        }
    }

    // When diagonal movement is allowed the manhattan heuristic is not
    // admissible, it should be octile instead
    if (this.diagonalMovement === DiagonalMovement.Never) {
        this.heuristic = opt.heuristic || Heuristic.manhattan;
    } else {
        this.heuristic = opt.heuristic || Heuristic.octile;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
weight = weight &gt;= 1 ? weight : 1; /* if negative or 0, use 1 */

timeLimit = parseInt($('#ida_section input[name=time_limit]').val());

// Any non-negative integer, indicates "forever".
timeLimit = (timeLimit &lt;= 0 || isNaN(timeLimit)) ? -1 : timeLimit;

finder = new PF.<span class="apidocCodeKeywordSpan">IDAStarFinder</span>({
  timeLimit: timeLimit,
  trackRecursion: trackRecursion,
  allowDiagonal: allowDiagonal,
  dontCrossCorners: dontCrossCorners,
  heuristic: PF.Heuristic[heuristic],
  weight: weight
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.JumpPointFinder" id="apidoc.element.pathfinding.PathFinding.JumpPointFinder">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>JumpPointFinder
        <span class="apidocSignatureSpan">(opt)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JumpPointFinder(opt) {
    opt = opt || {};
    if (opt.diagonalMovement === DiagonalMovement.Never) {
        return new JPFNeverMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.Always) {
        return new JPFAlwaysMoveDiagonally(opt);
    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {
        return new JPFMoveDiagonallyIfNoObstacles(opt);
    } else {
        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    break;

case 'jump_point_header':
    trackRecursion = typeof $('#jump_point_section ' +
                             '.track_recursion:checked').val() !== 'undefined';
    heuristic = $('input[name=jump_point_heuristic]:checked').val();

    finder = new PF.<span class="apidocCodeKeywordSpan">JumpPointFinder</span>({
      trackJumpRecursion: trackRecursion,
      heuristic: PF.Heuristic[heuristic],
      diagonalMovement: PF.DiagonalMovement.IfAtMostOneObstacle
    });
    break;
case 'orth_jump_point_header':
    trackRecursion = typeof $('#orth_jump_point_section ' +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.PathFinding.Node" id="apidoc.element.pathfinding.PathFinding.Node">
        function <span class="apidocSignatureSpan">pathfinding.PathFinding.</span>Node
        <span class="apidocSignatureSpan">(x, y, walkable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.Util" id="apidoc.module.pathfinding.Util">module pathfinding.Util</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.Util.backtrace" id="apidoc.element.pathfinding.Util.backtrace">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>backtrace
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function backtrace(node) {
    var path = [[node.x, node.y]];
    while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
    }
    return path.reverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// while the open list is not empty
while (!openList.empty()) {
    // pop the position of node which has the minimum `f` value.
    node = openList.pop();
    node.closed = true;

    if (node === endNode) {
        return Util.expandPath(Util.<span class="apidocCodeKeywordSpan">backtrace</span>(endNode));
    }

    this._identifySuccessors(node);
}

// fail to find the path
return [];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Util.biBacktrace" id="apidoc.element.pathfinding.Util.biBacktrace">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>biBacktrace
        <span class="apidocSignatureSpan">(nodeA, nodeB)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function biBacktrace(nodeA, nodeB) {
    var pathA = backtrace(nodeA),
        pathB = backtrace(nodeB);
    return pathA.concat(pathB.reverse());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Util.compressPath" id="apidoc.element.pathfinding.Util.compressPath">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>compressPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compressPath(path) {

    // nothing to compress
    if(path.length &lt; 3) {
        return path;
    }

    var compressed = [],
        sx = path[0][0], // start x
        sy = path[0][1], // start y
        px = path[1][0], // second point x
        py = path[1][1], // second point y
        dx = px - sx, // direction between the two points
        dy = py - sy, // direction between the two points
        lx, ly,
        ldx, ldy,
        sq, i;

    // normalize the direction
    sq = Math.sqrt(dx*dx + dy*dy);
    dx /= sq;
    dy /= sq;

    // start the new path
    compressed.push([sx,sy]);

    for(i = 2; i &lt; path.length; i++) {

        // store the last point
        lx = px;
        ly = py;

        // store the last direction
        ldx = dx;
        ldy = dy;

        // next point
        px = path[i][0];
        py = path[i][1];

        // next direction
        dx = px - lx;
        dy = py - ly;

        // normalize
        sq = Math.sqrt(dx*dx + dy*dy);
        dx /= sq;
        dy /= sq;

        // if the direction has changed, store the point
        if ( dx !== ldx || dy !== ldy ) {
            compressed.push([lx,ly]);
        }
    }

    // store the last point
    compressed.push([px,py]);

    return compressed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Note that the new path will be compressed as well, i.e. if the original path is
`[[0, 1], [0, 2], [0, 3], [0, 4]]`, then the new path will be `[[0, 1], [0, 4]]`.

To just compress a path without smoothing it, you may use `PF.Util.compressPath`.

```javascript
var newPath = PF.Util.<span class="apidocCodeKeywordSpan">compressPath</span>(path);
```

To expand the compressed path like `[[0, 1], [0, 4]]` back to `[[0, 1], [0, 2], [0, 3], [0, 4]]`,
you may use `PF.Util.expandPath`.

```javascript
var newPath = PF.Util.expandPath(path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Util.expandPath" id="apidoc.element.pathfinding.Util.expandPath">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>expandPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expandPath(path) {
    var expanded = [],
        len = path.length,
        coord0, coord1,
        interpolated,
        interpolatedLen,
        i, j;

    if (len &lt; 2) {
        return expanded;
    }

    for (i = 0; i &lt; len - 1; ++i) {
        coord0 = path[i];
        coord1 = path[i + 1];

        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
        interpolatedLen = interpolated.length;
        for (j = 0; j &lt; interpolatedLen - 1; ++j) {
            expanded.push(interpolated[j]);
        }
    }
    expanded.push(path[len - 1]);

    return expanded;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var newPath = PF.Util.compressPath(path);
```

To expand the compressed path like `[[0, 1], [0, 4]]` back to `[[0, 1], [0, 2], [0, 3], [0, 4]]`,
you may use `PF.Util.expandPath`.

```javascript
var newPath = PF.Util.<span class="apidocCodeKeywordSpan">expandPath</span>(path);
```


Development
------------

Layout:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Util.interpolate" id="apidoc.element.pathfinding.Util.interpolate">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>interpolate
        <span class="apidocSignatureSpan">(x0, y0, x1, y1)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function interpolate(x0, y0, x1, y1) {
    var abs = Math.abs,
        line = [],
        sx, sy, dx, dy, err, e2;

    dx = abs(x1 - x0);
    dy = abs(y1 - y0);

    sx = (x0 &lt; x1) ? 1 : -1;
    sy = (y0 &lt; y1) ? 1 : -1;

    err = dx - dy;

    while (true) {
        line.push([x0, y0]);

        if (x0 === x1 &amp;&amp; y0 === y1) {
            break;
        }

        e2 = 2 * err;
        if (e2 &gt; -dy) {
            err = err - dy;
            x0 = x0 + sx;
        }
        if (e2 &lt; dx) {
            err = err + dx;
            y0 = y0 + sy;
        }
    }

    return line;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Util.pathLength" id="apidoc.element.pathfinding.Util.pathLength">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>pathLength
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pathLength(path) {
    var i, sum = 0, a, b, dx, dy;
    for (i = 1; i &lt; path.length; ++i) {
        a = path[i - 1];
        b = path[i];
        dx = a[0] - b[0];
        dy = a[1] - b[1];
        sum += Math.sqrt(dx * dx + dy * dy);
    }
    return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.pathfinding.Util.smoothenPath" id="apidoc.element.pathfinding.Util.smoothenPath">
        function <span class="apidocSignatureSpan">pathfinding.Util.</span>smoothenPath
        <span class="apidocSignatureSpan">(grid, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function smoothenPath(grid, path) {
    var len = path.length,
        x0 = path[0][0],        // path start x
        y0 = path[0][1],        // path start y
        x1 = path[len - 1][0],  // path end x
        y1 = path[len - 1][1],  // path end y
        sx, sy,                 // current start coordinate
        ex, ey,                 // current end coordinate
        newPath,
        i, j, coord, line, testCoord, blocked;

    sx = x0;
    sy = y0;
    newPath = [[sx, sy]];

    for (i = 2; i &lt; len; ++i) {
        coord = path[i];
        ex = coord[0];
        ey = coord[1];
        line = interpolate(sx, sy, ex, ey);

        blocked = false;
        for (j = 1; j &lt; line.length; ++j) {
            testCoord = line[j];

            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
                blocked = true;
                break;
            }
        }
        if (blocked) {
            lastValidCoord = path[i - 1];
            newPath.push(lastValidCoord);
            sx = lastValidCoord[0];
            sy = lastValidCoord[1];
        }
    }
    newPath.push([x1, y1]);

    return newPath;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

To smoothen the path, you may use `PF.Util.smoothenPath`. This routine will return
a new path with the original one unmodified.

```javascript
var newPath = PF.Util.<span class="apidocCodeKeywordSpan">smoothenPath</span>(grid, path);
```

Note that the new path will be compressed as well, i.e. if the original path is
`[[0, 1], [0, 2], [0, 3], [0, 4]]`, then the new path will be `[[0, 1], [0, 4]]`.

To just compress a path without smoothing it, you may use `PF.Util.compressPath`.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.parse_map" id="apidoc.module.pathfinding.parse_map">module pathfinding.parse_map</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.parse_map.parse" id="apidoc.element.pathfinding.parse_map.parse">
        function <span class="apidocSignatureSpan">pathfinding.parse_map.</span>parse
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(filename) {
  var content = fs.readFileSync(filename).toString();
  var lines = content.split(endOfLine);
  return {
    height : parseInt(lines[1].split(' ')[1]),
    width  : parseInt(lines[2].split(' ')[1]),
    grid   : parseGrid(lines.slice(4)),
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.pathfinding.parse_scen" id="apidoc.module.pathfinding.parse_scen">module pathfinding.parse_scen</a></h1>


    <h2>
        <a href="#apidoc.element.pathfinding.parse_scen.parse" id="apidoc.element.pathfinding.parse_scen.parse">
        function <span class="apidocSignatureSpan">pathfinding.parse_scen.</span>parse
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parse(filename) {
  var content = fs.readFileSync(filename).toString();
  var lines = content.split('\n');
  var version = lines[1].split(/\s+/);
  return {
    version: version,
    scenarios: lines.slice(1, lines.length - 1).map(parseLine)
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>